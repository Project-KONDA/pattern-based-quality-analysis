+++ Translation of a Pattern to XQuery +++

// see class diagram in "qualitypatternmodel.jpg"

_____________Explanation:_____________


Desired Result:
	The result of a pattern is the set of Return Elements specified in the Return Graph, which satisfy the specified conditions.
	The Return Graph may include Primitive Conditions (e.g. regarding an element's property). 
	Other conditions (e.g. regarding the existence of child elements) are specified as Complex Conditions via nested QuantifiedConditions that each include a Graph.
		
	
Return Graph:
	Specifies which elements should be returned by the pattern by indicating the path from the XML Root Element to the Return Elements.
	May contain primitive conditions refering to properties of the root or return elements or the elements on the path between them.
	
Return Element: 
	One or more elements, which should be returned as the Result when applying the pattern.
	if (multiple elements are specified as Return Elements, pairs of elements are returned.
		(In that case, we want to add an addtional XML element (<break/>) between the pairs.
		This is, because nesting these pairs in an element is inefficient.)
	
Primitive Conditions:
	Simple conditions which can be evaluated solely on a single element (whose tag name, attribute values or content data they refer to) 
		and do not depend on any further elements. 

Complex Conditions:
	combinations of QuantifiedConditions and Formulas
	additional conditions regarding the XML structure of the return elements and their related elements
	
		QuantifiedCondition:
			contains a Graph which specifies the elements involved in the condition as well as their relations and properties
			specifies a quantifier for the elements new in this graph: exists or forall
			contains a nested QuantifiedCondition
			
		Formula:
			(1 argument:) NOT
			(2 arguments:) AND, OR, XOR, IMPLIES, XNOR (EQUIVALENT)
			contains Complex Condition(s) as arguments
	
		True:
			Leave of a Complex Condition

Graph:
	describes Nodes and Relationships between them (based on XPath axes)
	Additionally, Conditions can be defined via boolean functions over the property of a node or properties of multiple different nodes.
	
	Node: 
		XML element
	Relation:
		Relative position (based on XPath axes) of an XML element in relation to another XML element
	Propety:
		XML tag name, attribute values, content data
		

Query as the result of the pattern translation:
	for <every possible Result (Return Element)>
	where 
		<test for complex conditions (combinations of quantified conditions and formulas)>
	return <Result>
	
	for:
		The Query iterates through the elements specified in the Return Graph (from the XML Root Element to the Return Element(s)) using nested for clauses.
		
	where:
		QuantifiedCondition are translated into nested some and every clauses.
		Formulas are expressed directly via the corresponding operators.		
	
	return:
		variable(s) of the Return Element(s)
		


_____________Abstract Algorithm:_____________


translate returnGraph 
	by traversing the graph and adding a FOR clause for each visited element
	for $id<element.id> in <xPathExpression>[<xPredicate>]*
		the xPathExpression encodes the relation to the previous element
		each xPredicate encodes a primitive condition on one of the element's properties
	

translate each condition nested in the pattern
	in case of a QuantifiedCondition: traverse the graph and nest a SOME or EVERY clause into the WHERE clause for each visited element
		{some, every} $id<element.id> in <xPathExpression>[xPredicate]* satisfies
			the xPathExpression encodes the relation to the previous element
			each xPredicate encodes a condition on a propertiy of an element or on properties of multiple different elements 
				(this also includes statements about sets of elements)
	in case of a Formula: append the logical operator to the WHERE clause and translate its arguments

add a RETURN clause for returning the variables representing the pattern's return elements


_____________Detailed Algorithm:_____________


String translatePatternToXQuery(Pattern pattern){	
	for (Element element: pattern.graphs.elements) element.isTranslated = false;
	String forClauses = translateReturnGraph();
	String whereClause = "where " + translateConditions();
	String returnClause = "return $id" + pattern.returnGraph.returnElement;
	return forClauses + whereClause + returnClause;
}
	
String translateReturnGraph(){	
	return translateSingleElementReturnGraph(pattern.returnGraph.rootElement);
}
		
String translateSingleElementReturnGraph(SingleElement element){		
	String xPathExpression = translatePathFromPrevious(element);	
	String xPredicates = translatePredicates(element);		
	
	String forClauses = "for " + "$id" + element.getOriginalID() + " in " + xPathExpression + xPredicates + "\n";
	
	element.isTranslated = true;
	
	for (SingleElement nextElement : element.getNextElements()){
		forClauses += translateSingleElementReturnGraph(nextElement);
	}
	
	return forClauses;
}

boolean booleanOperatorIsReady(BooleanOperator booleanOperator){
	if (predicate instanceof Comparison){
		Comparison comparison = (Comparison) predicate;
		return isReady(comparison.argument1) && isReady(comparison.argument2);
	}
	if (predicate instanceof Match){
		Match match = (Match) predicate;
		return isReady(match.property);
	}
}

boolean numberOperatorIsReady(NumberOperator numberOperator){
	if (numberOperator instanceof Count){
		Count count = (Count) numberOperator;
		return isReady(count.argument);
	}
	if (numberOperator instanceof ToNumber){
		ToNumber toNumber = (ToNumber) numberOperator;
		return isReady(toNumber.property);
	}
}

boolean isReady(GraphElement element){
	if (element instanceof Property){
		Property property = (Property) element;
		return property.element.isTranslated;
	} else if (element instanceof BooleanOperator){
		BooleanOperator booleanOperator = (BooleanOperator) element;
		return booleanOperatorIsReady(booleanOperator);
	} else if (element instanceof NumberOperator){
		NumberOperator numberOperator = (NumberOperator) element;
		return numberOperatorIsReady(numberOperator);
	} else if (element instanceof SetElement){
		SetElement setElement = (SetElement) element;
		return setElement.getPreviousElement().isTranslated;
	} else if (element instanceof SingleElement){
		SingleElement singleElement = (SingleElement) element;
		return singleElement.isTranslated;
	} else {
		return true;
	}
}

String translatePathFromPrevious(Element element){
	if(element instanceof SingleElement){
		if(element.getPreviousElement() != null){
			return element.getPreviousElement().getId() + "/" + element.relationFromPrevious.axis + "::*";
		} else {
			return "/*";
		}
	} else if (element instanceof SetElement){
		return "/" + element.relationFromPrevious.axis + "::*";
	}
}

String translatePredicates(Element element){
	String xPredicates = "";
	for (BooleanOperator predicate : element.predicates){
		if ((booleanOperatorIsReady(predicate)){
			xPredicates += "[" + translatePredicate(predicate, element) + "]";
		}
	}
	return xPredicates;
}
		
String translatePredicate(BooleanOperator predicate, Element element){
	if (predicate instanceof Comparison){
		Comparison comparison = (Comparison) predicate;
		String operator = comparison.options.selection.getLiteral();
		return translateArgument(comparison.argument1,element) + operator + translateArgument(comparison.argument2,element);
	}
	if (predicate instanceof Match){
		Match match = (Match) predicate;
		if (match.options.selection){
			return "match(" + translateArgument(match.argument,element) + "," + match.regularExpression.text + ")";
		} else {
			return "not(match(" + translateArgument(match.argument,element) + "," + match.regularExpression.text + "))";
		}		
	}
}

String translateOperator(Operator operator, Element element){
	if (operator instanceof NumberOperator){
		NumberOperator numberOperator = (NumberOperator) operator;
		return translateNumberOperator(numberOperator,element);
	}
	if (operator instanceof BooleanOperator){
		BooleanOperator booleanOperator = (BooleanOperator) operator;
		return translatePredicate(booleanOperator,element);
	}
}

String translateNumberOperator(NumberOperator numberOperator, Element element){	
	if (numberOperator instanceof Count){
		Count count = (Count) numberOperator;
		return "count(" + translateArgument(count.argument) + ")";
	}
	if (numberOperator instanceof ToNumber){
		ToNumber toNumber = (ToNumber) numberOperator;
		return "fn:number(" + translateArgument(toNumber.property) + ")";
	}
}

String translateArgument(GraphElement argument, Element element){
	if (argument instanceof Input){ 
		Input input = (Input) argument;
		if (input instanceof Text){
			Text text = (Text) input;
			return text.text;
		}
		if (input instanceof Number){
			Number number = (Number) input;
			return number.number;
		}
		if (input instanceof Boolean){
			Boolean bool = (Boolean) input;
			return bool.bool;
		}
	}		
	if (argument instanceof Property){ 
		Property property = (Property) argument;
		Element propertyElement = property.getElement();
		String propertyElementTranslation = translateArgument(propertyElement,element);
		String location = property.options.selection;		
		if (location = DATA){
			return propertyElementTranslation + "/data()";
		}
		if (location = TAG){
			return propertyElementTranslation + "/name()"
		}
		if (location = ATTRIBUTE){
			return propertyElementTranslation + "/@" + property.attributeName;		
		}
	}		
	if (argument instanceof SingleElement){ 
		SingleElement singleElement = (SingleElement) argument;
		if (singleElement.equals(element)){
			return ".";
		} else {
			return "$id" + singleElement.getOriginalID();
		}
	}
	if (argument instanceof SetElement){ 
		SetElement setElement = (SetElement) argument;
		Element predicateOwnerElement = element;
		return translatePathFromPreviousFromSetElement(setElement,predicateOwnerElement,"");				
	}
	if (argument instanceof Operator){ 
		Operator operator = (Operator) argument;
		return translateOperator(operator,element);
	}
}

String translatePathFromPreviousFromSetElement(Element element, Element predicateOwnerElement, String xPathExpression){	
	if (element.equals(predicateOwnerElement)){
		if(predicateOwnerElement instanceof SingleElement){
			return "$id" + ((SingleElement) predicateOwnerElement).getOriginalID() + xPathExpression;
		} else {
			return ".";
		}
	}			
	xPathExpression = translatePathFromPrevious(element) + translatePredicates(element) 
		+ translateElementExistencePredicates(pathElement) + xPathExpression;
	element.isTranslated = true;	
	return translatePathFromPreviousFromSetElement(element.getPreviousElement(), predicateOwnerElement, xPathExpression);
}

String translateElementExistencePredicates(Element pathElement){		
	String predicates = "";
	for (SetElement nextSetElement : pathElement.next){
		if (!nextSetElement.isTranslated){
			nextSetElement.isTranslated = true;
			predicates += "[." + translatePathFromPrevious(nextSetElement) + translatePredicates(nextSetElement)
				+ translateElementExistencePredicates(nextSetElement) + "]"; 			
		}										
	}
	return predicates;
}

String translateConditions(){
	return translateCondition(pattern.condition);
}

String translateCondition(Condition condition){
	if (condition instanceof QuantifiedCondition){	
		QuantifiedCondition quantifiedCondition = (QuantifiedCondition) condition;		
		return translateSingleElementConditionGraph(quantifiedCondition.graph.rootElement) + translateCondition(quantifiedCondition.condition);		
	}		
	if (condition instanceof Formula){
		Formula formula = (Formula) condition;	
		if (formula.operator == NOT){
			return "not(" + translateCondition(formula.arguments.get(0)) + ")";
		} else {
			return "(" + translateCondition(formula.arguments.get(0)) + ")" + formula.operator + "(" + translateCondition(formula.arguments.get(1)) + ")"; 
		}		
	}
		
	if (condition instanceof True){
		return "true";
	}
}

String translateSingleElementConditionGraph(SingleElement element){
	String xPathExpression = translatePathFromPrevious(element);		
	String xPredicates = translatePredicates(element);		
	if (element.mappingTo == null){					
		forClauses = quantifiedCondition.quantifier.getLiteral() + " $id" + element.getOriginalID() " in " + xPathExpression + xPredicates + " satisfies \n";			
	} else {		
		forClauses = quantifiedCondition.quantifier.getLiteral() + " $id" + element.getOriginalID() " in $id" + element.getOriginalID() + xPredicates + " satisfies \n";
	}
	
	element.isTranslated = true;
	
	for (SingleElement nextElement : element.getNextElements()){
		forClauses += translateSingleElementConditionGraph(nextElement);
	}
	
	return forClauses;
}
	