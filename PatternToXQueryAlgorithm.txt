+++ Translation of Pattern to XQuery +++

// see class diagram in "qualitypatternmodel.jpg"
// class names are written in upper case letters in the following algorithm

initialization:
	boolean ELEMENT.isTarget := true if the ELEMENT is the target of a mapping, thus if it has already been translated to XQuery				
	boolean BOOLEANOPERATOR.isReady := true if the BOOLEANOPERATOR only references (PROPERTies of) other SINGLEELEMENTs which were already translated (Element.isTranslated) or SETELEMENTS or other BOOLEANOPERATORs with isReady

translation of the return graph (PATTERN.return of type GRAPH): 
	(basis for XQuery: for, where, return)

	for-clauses: 
		(specification of the output via (multiple nested) for-clauses)
		
		starting at the GRAPH.root element navigate through graph of connected SINGLEELEMENTs via ELEMENT.nextElements: 
		for each element of type SINGLEELEMENT:
			add for clause: for $id<element.id> in <xPathExpression>[xPredicate]*
				(create variable based on element ID)
			generate xPathExpression: 
				translate element.relationsFromPreviousElement by appending the corresponding axes to the variable representing element.previousElement
			generate xPredicate:
				for each predicate of type BOOLEANOPERATOR in element.predicates where predicate.isReady: 
					translate predicate by navigating through graph of operators and arguments
						- translate operator: directly transfer notation
						- translate arguments:
							- INPUT: 
								- input value can be directly put into the XQuery
							- PROPERTY:
								- translate DATA to data()
								- translate TAG to name()
								- translate ATTRIBUTE to @<attributeName>
							- ELEMENT: 
								- variable name or "." (self)
							- ELEMENTSET:
								- create path expression by navigating to previous single element 
								- append predicates translated as described here
							- OPERATOR: 
								- put operator-function into the XQuery
								- translate arguments recursively	
			element.isTranslated = true		
	where-clause: 
		(conditions)
		where <empty, space to fill during translation of CONDITIONs>
		
	return-clause: 
		return <variable representing the return element>
		

translation of CONDITIONs nested in PATTERN:
	for each condition of type CONDITION nested in PATTERN:
	(where-clause is built incrementally)

		if condition is of type QUANTIFIEDCONDITION:	
			starting at the GRAPH.root element navigate through graph of connected SINGLEELEMENTs via SINGLEELEMENT.nextElements: 
			for each element of type SINGLEELEMENT:		
				if !element.isTarget:
					translate element.relationsFromPreviousElement (-> xPathExpression) and element.predicates where isReady (-> xPredicate): see above (lines 20 to 40)
					if quantifier = EXISTS:
						where clause += some $id<element.id> in <xPathExpression>[xPredicate]* satisfies			
					else if quantifier = FORALL:
						where clause += every $id<element.id> in <xPathExpression>[xPredicate]* satisfies					
				else:
					translate element.predicates where isReady (-> xPredicate): see above (lines 22 to 40)
					if quantifier = EXISTS:
						where clause += some $id<element.id> in $id<element.id>[xPredicate]* satisfies
					else if quantifier = FORALL:
						where clause += every $id<element.id> in $id<element.id>[xPredicate]* satisfies
					
		if condition is of type FORMULA:
			translate logical operator directly
			translate nested CONDITIONs as described above
			
		if condition is of type TRUE:
			close where-clause
