+++ Translation of Pattern to XQuery +++

// see class diagram in "qualitypatternmodel.jpg"
// class names are written in upper case letters in the following algorithm

initialization:
	boolean ELEMENT.isTarget := true if the ELEMENT is the target of a mapping, thus if it has already been translated to XQuery				
	boolean BOOLEANOPERATOR.isReady := true if the BOOLEANOPERATOR only references 
											- (PROPERTies of) other SINGLEELEMENTs which were already translated (SINGLEELEMENT.isTranslated) 
											- or SETELEMENTS whose closest preceding SINGLEELEMENT was already translated (SINGLEELEMENT.isTranslated) 
											- or other BOOLEANOPERATORs with isReady
	
	for each element of type ELEMENT: element.isTranslated = false
	
translation of the return graph (PATTERN.return of type GRAPH): 
	(basis for XQuery: for, where, return)

	for-clauses: 
		(specification of the output via (multiple nested) for-clauses)
		
		starting at the GRAPH.root element navigate through graph of connected SINGLEELEMENTs via ELEMENT.nextElements: 
		for each element of type SINGLEELEMENT:
			add for clause: for $id<element.id> in <xPathExpression>[xPredicate]*
				(create variable based on element ID)
			generate xPathExpression: 
				translate element.relationsFromPreviousElement by appending the corresponding axes to the variable representing element.previousElement
			generate xPredicate:
				for each predicate of type BOOLEANOPERATOR in element.predicates where predicate.isReady: 
					translate predicate by navigating through graph of operators and arguments
						- translate operator: directly transfer notation
						- translate arguments:
							- INPUT: 
								input value can be directly put into the XQuery
							- PROPERTY:
								- translate DATA to data()
								- translate TAG to name()
								- translate ATTRIBUTE to @<attributeName>
							- ELEMENT: 
								variable name or "." (self)
							- setElement of type SETELEMENT:
								let predicateOwnerElement of type ELEMENT be the element which references the predicate containing the set operation which has setElement as an argument									
								generate xPathExpression:									
									navigate from setElement to predicateOwnerElement: 
									for each pathElement of type SETELEMENT:										
										xPathExpression = translated pathElement.relationsFromPreviousElement + translated pathElement.predicates + xPathExpression (see lines 20 to 52)
										pathElement.isTranslated = true
									xPathExpression = variable representing predicateOwnerElement + xPathExpression
								generate xPredicates string of the form [xPredicate]*:
									xPredicates += translated setElement.predicates (see lines 22 to 52)
									for each nextSetElement of type SETELEMENT in setElement.next with !nextSetElement.isTranslated:
										xPredicates += predicate requiring the existence of nextSetElement in the form [./<xPathExpression>[xPredicate]*] (see lines 20 to 52)
								put <xPathExpression><xPredicates> into the XQuery
							- OPERATOR:
								put operator-function into the XQuery
								translate arguments recursively	
			element.isTranslated = true		
	where-clause: 
		(conditions)
		where <empty, space to fill during translation of CONDITIONs>
		
	return-clause: 
		return <variable representing the return element>
		

translation of CONDITIONs nested in PATTERN:
	for each condition of type CONDITION nested in PATTERN:
	(where-clause is built incrementally)

		if condition is of type QUANTIFIEDCONDITION:	
			starting at the GRAPH.root element navigate through graph of connected SINGLEELEMENTs via SINGLEELEMENT.nextElements: 
			for each element of type SINGLEELEMENT:		
				if !element.isTarget:
					translate element.relationsFromPreviousElement (-> xPathExpression) and element.predicates where isReady (-> xPredicate): see lines 20 to 52
					if quantifier = EXISTS:
						where clause += some $id<element.id> in <xPathExpression>[xPredicate]* satisfies			
					else if quantifier = FORALL:
						where clause += every $id<element.id> in <xPathExpression>[xPredicate]* satisfies					
				else:
					translate element.predicates where isReady (-> xPredicate): see lines 22 to 52
					if quantifier = EXISTS:
						where clause += some $id<element.id> in $id<element.id>[xPredicate]* satisfies
					else if quantifier = FORALL:
						where clause += every $id<element.id> in $id<element.id>[xPredicate]* satisfies
					
		if condition is of type FORMULA:
			translate logical operator directly
			translate nested CONDITIONs as described above
			
		if condition is of type TRUE:
			close where-clause
