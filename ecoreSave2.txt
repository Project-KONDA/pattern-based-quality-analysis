import ecore : 'http://www.eclipse.org/emf/2002/Ecore#/' ;

package qualitypatternmodel : qualitypatternmodel = 'qualitypatternmodel'
{
	package inputfields : inputfields = 'inputfields'
	{
		abstract class Input extends qualitypatternmodel::graphstructure::GraphElement
		{
			operation inputIsValid() : Boolean[1];
			operation getAllArgumentElements() : Set(Set(qualitypatternmodel::graphstructure::Element))
			{
				body: 					
					Set{};
			}
			property variableList#variables : VariableList[1];
			attribute description : String[?];
			attribute isPredefined : Boolean[1];
			callable invariant validate;
		}
		class Number extends Input
		{
			attribute value : ecore::EDoubleObject[?] = '0';
		}
		class _'Boolean' extends Input
		{
			attribute value : Boolean[?] = 'true';
		}
		class Text extends Input
		{
			attribute value : String[?] = '';
		}
		class CompOption extends Input
		{
			attribute options : qualitypatternmodel::functions::ComparisonOperator[*|1] { ordered };
			attribute value : qualitypatternmodel::functions::ComparisonOperator[?];
		}
		class PropertyOption extends Input
		{
			attribute options : qualitypatternmodel::graphstructure::PropertyLocation[*|1] { ordered };
			attribute value : qualitypatternmodel::graphstructure::PropertyLocation[?];
		}
		class VariableList extends qualitypatternmodel::patternstructure::PatternElement
		{
			property variables#variableList : Input[*|1] { ordered composes };
			property pattern#variableList : qualitypatternmodel::patternstructure::Pattern[1];
		}
	}
	package functions : functions = 'functions'
	{
		abstract class BooleanOperator extends Operator
		{
			property elements#predicates : qualitypatternmodel::graphstructure::Element[*|1] { ordered };
			invariant predicateIsValid : self.checkPredicateValid();
			operation checkPredicateValid() : Boolean
			{
				body: 
					self.elements->forAll(e: qualitypatternmodel::graphstructure::Element | self.getAllArgumentElements()->includes(e))
					and
					self.getAllArgumentElements()->forAll(l: Set(qualitypatternmodel::graphstructure::Element) | l->exists(e: qualitypatternmodel::graphstructure::Element | elements->includes(e)));
			}
			operation getAllArgumentElements() : Set(Set(qualitypatternmodel::graphstructure::Element)) 
			{
				body: 
					if self.oclIsTypeOf(Comparison) then 
						self.oclAsType(Comparison).argument1.getAllArgumentElements()->union(self.oclAsType(Comparison).argument2.getAllArgumentElements())
					else 
						if self.oclIsTypeOf(Match) then
							self.oclAsType(Match).property.getAllArgumentElements()
						else 
							Set{}
						endif
					endif;
			}
		}
		abstract class Operator extends qualitypatternmodel::graphstructure::GraphElement
		{
			operation getAllOperators() : Operator[*|1] throws
			qualitypatternmodel::patternstructure::InvalidityExceptionWrapper { ordered };
			callable invariant validate;
			operation getAllArgumentElements() : Set(Set(qualitypatternmodel::graphstructure::Element)) ; 
		}
		class Count extends NumberOperators
		{
			property argument : qualitypatternmodel::graphstructure::SetElement[1];
			operation getAllArgumentElements() : Set(Set(qualitypatternmodel::graphstructure::Element)) 
			{
				body: 
					self.argument.getAllArgumentElements();
			}
		}
		abstract class OtherOperators extends Operator
		{
			operation getAllArgumentElements() : Set(Set(qualitypatternmodel::graphstructure::Element)) 
			{
				body: 					
					Set{};									
			}
		}
		abstract class NumberOperators extends Operator;
		class Match extends BooleanOperator
		{
			property property : qualitypatternmodel::graphstructure::Property[1];
			property regularExpression : qualitypatternmodel::inputfields::Text[1];
			property option : qualitypatternmodel::inputfields::Boolean[1];
		}
		class Comparison extends BooleanOperator
		{
			property argument1 : qualitypatternmodel::graphstructure::GraphElement[1];
			property option : qualitypatternmodel::inputfields::CompOption[1];
			property argument2 : qualitypatternmodel::graphstructure::GraphElement[1];
		}
		class ToNumber extends NumberOperators
		{
			property property : qualitypatternmodel::graphstructure::Property[1];
			operation getAllArgumentElements() : Set(Set(qualitypatternmodel::graphstructure::Element)) 
			{
				body: 
					self.property.getAllArgumentElements();
			}
		}
		enum ComparisonOperator { serializable }
		{
			literal EQUAL : '=';
			literal GREATER : '>' = 1;
			literal LESS : '<' = 2;
			literal GREATEROREQUAL : '>=' = 3;
			literal LESSOREQUAL : '<=' = 4;
			literal NOTEQUAL : '!=' = 5;
		}
		class OperatorList extends qualitypatternmodel::patternstructure::PatternElement
		{
			property operators : Operator[*|1] { ordered composes };
			property graph#operatorList : qualitypatternmodel::graphstructure::Graph[1];
		}
	}
	package graphstructure : graphstructure = 'graphstructure'
	{
		class Relation extends qualitypatternmodel::patternstructure::PatternElement
		{
			operation getGraphDepth() : ecore::EInt[1];
			property mappingFrom#to : qualitypatternmodel::patternstructure::RelationMapping[?];
			property mappingTo#from : qualitypatternmodel::patternstructure::RelationMapping[?];
			attribute axis : Axis[?];
			property relationTo#relationFromPrevious : Element[1];
		}
		class Property extends GraphElement
		{
			property propertyOption : qualitypatternmodel::inputfields::PropertyOption[1];
			property element#properties : Element[1];
			property attributeName : qualitypatternmodel::inputfields::Text[1];
			operation getAllArgumentElements() : Set(Set(Element)) 
			{
				body: 						
					if self.element.oclIsTypeOf(SingleElement) then			
						self.element.oclAsType(SingleElement).getAllArgumentElements()
					else
						if self.element.oclIsTypeOf(SetElement) then			
							self.element.oclAsType(SetElement).getAllArgumentElements()
						else 
							Set{}
						endif
					endif;
			}
		}
		class SingleElement extends Element
		{
			operation getOriginalID() : ecore::EInt[1];
			operation getXQueryVariable() : String[?];
			operation translatePredicates(location : qualitypatternmodel::patternstructure::Location[?]) : String[?] throws
			qualitypatternmodel::patternstructure::InvalidityExceptionWrapper;
			operation translatePathFromPrevious() : String[?];
			property mappingTo#from : qualitypatternmodel::patternstructure::SingleElementMapping[*|1] { ordered };
			property mappingFrom#to : qualitypatternmodel::patternstructure::SingleElementMapping[?];
			property root#rootElement : Graph[?];
			invariant hasPreviousOrIsRoot: self.previous->notEmpty() or self.root->notEmpty();
			operation getAllArgumentElements() : Set(Set(Element))
			{
				body: 					
					Set{Set{self}};					
			}
		}
		class SetElement extends Element
		{
			operation translateElementExistencePredicates(location : qualitypatternmodel::patternstructure::Location[?], depth
				: ecore::EInt[1]) : String[?] throws qualitypatternmodel::patternstructure::InvalidityExceptionWrapper;
			operation translatePathFromPrevious(depth : ecore::EInt[1]) : String[?];
			operation translatePredicates(location : qualitypatternmodel::patternstructure::Location[?], depth :
				ecore::EInt[1]) : String[?] throws qualitypatternmodel::patternstructure::InvalidityExceptionWrapper;
			attribute nestingDepth : ecore::EInt[1];
			invariant hasPrevious: self.previous->notEmpty();
			operation getAllArgumentElements() : Set(Set(Element)) 
			{
				body: 					
					Set{self.oclAsType(SetElement).getSetPrevious};

			}
			property getSetPrevious : Set(Element) { derived volatile }
			{
				initial: 					
					if self.previous.oclIsTypeOf(SetElement) then	
						self.previous.oclAsType(SetElement).getSetPrevious->including(self)
					else 
						if self.previous.oclIsTypeOf(SingleElement) then	
							Set{self.previous}
						else 
							Set{}
							endif
						endif;

			}
		}
		abstract class Element extends GraphElement
		{
			operation getNextElements() : Element[*|1] { ordered };
			operation getPreviousElement() : Element[?];
			operation getAllOperators() : qualitypatternmodel::functions::Operator[*|1] throws
			qualitypatternmodel::patternstructure::InvalidityExceptionWrapper { ordered };
			operation getAllVariables() : qualitypatternmodel::inputfields::Input[*|1] throws
			qualitypatternmodel::patternstructure::InvalidityExceptionWrapper { ordered };
			operation getXQueryRepresentation(location : qualitypatternmodel::patternstructure::Location[?], depth :
				ecore::EInt[1]) : String[?] throws qualitypatternmodel::patternstructure::InvalidityExceptionWrapper;
			operation getContextRepresentation(depth : ecore::EInt[1]) : String[?] throws
			qualitypatternmodel::patternstructure::InvalidityExceptionWrapper;
			operation getGraphDepth() : ecore::EInt[1];
			property relationFromPrevious#relationTo : Relation[?] { composes };
			attribute translated : Boolean[1];
			property properties#element : Property[*|1] { ordered composes };
			attribute predicatesAreBeingTranslated : Boolean[1];
			property getAllElements : Element[*] { derived volatile }
			{
				initial: 
				 self.getNextElements()->collect(e: Element | e.getAllElements)->asSet()->including(self);
			}
			property getAllRelations : Relation[*] { derived volatile }
			{
				initial: 
				 self.getNextElements()->collect(e: Element | e.getAllRelations)->asSet()->including(self.relationFromPrevious);
			}
			property next#previous : Element[*|1] { ordered composes };
			property previous#next : Element[?];
			property predicates#elements : qualitypatternmodel::functions::BooleanOperator[*|1] { ordered };
			operation getAllArgumentElements() : Set(Set(Element));
		}
		class Graph extends qualitypatternmodel::patternstructure::PatternElement
		{
			operation getAllOperators() : qualitypatternmodel::functions::Operator[*|1] throws
			qualitypatternmodel::patternstructure::InvalidityExceptionWrapper { ordered };
			property returnElements : SingleElement[+|1] { ordered };
			property rootElement#root : SingleElement[1] { composes };
			property operatorList#graph : qualitypatternmodel::functions::OperatorList[1] { composes };
			attribute graphDepth : ecore::EInt[1] = '-1';
			attribute returnGraph : Boolean[1] = 'false';
			property getAllElements : Element[*] { derived volatile }
			{
				initial: 
				self.rootElement.getAllElements;
			}
			property getAllRelations : Relation[*] { derived volatile }
			{
				initial: 
				self.rootElement.getAllRelations;
			}
		}
		abstract class GraphElement extends qualitypatternmodel::patternstructure::PatternElement
		{
			operation getReturnType() : ReturnType[?];
			operation isTranslatable() : Boolean[1];
			operation toXQuery(location : qualitypatternmodel::patternstructure::Location[?], depth : ecore::EInt[1]) :
			String[?] throws qualitypatternmodel::patternstructure::InvalidityExceptionWrapper;
			callable invariant validate;
			operation getAllArgumentElements() : Set(Set(Element));
		}
		enum PropertyLocation { serializable }
		{
			literal DATA : 'DATA';
			literal TAG : 'TAG' = 1;
			literal ATTRIBUTE : 'ATTRIBUTE' = 2;
		}
		enum Axis { serializable }
		{
			literal CHILD : 'child';
			literal DESCENDANT : 'descendant' = 1;
			literal PARENT : 'parent' = 2;
			literal ANCESTOR : 'ancestor' = 3;
			literal FOLLOWING : 'following' = 4;
			literal FOLLOWING_SIBLING : 'following-sibling' = 5;
			literal PRECEDING : 'preceding' = 6;
			literal PRECEDING_SIBLING : 'preceding-sibling' = 7;
			literal ANCESTOR_OR_SELF : 'ancestor-or-self' = 8;
			literal DESCENDANT_OR_SELF : 'descendant-or-self' = 9;
		}
		enum ReturnType { serializable }
		{
			literal NUMBER;
			literal STRING = 1;
			literal BOOLEAN = 2;
			literal NONE = 3;
			literal ELEMENT = 4;
		}
	}
	package patternstructure : patternstructure = 'patternstructure'
	{
		class RelationMapping extends Mapping
		{
			property to#mappingFrom : qualitypatternmodel::graphstructure::Relation[1];
			property from#mappingTo : qualitypatternmodel::graphstructure::Relation[1];
		}
		class QuantifiedCondition extends Condition
		{
			property condition : Condition[1] { composes };
			property graph : qualitypatternmodel::graphstructure::Graph[1] { composes };
			property morphism : Morphism[1] { composes };
			attribute quantifier : Quantifier[?];
			attribute checkMorphismOfNextGraph : Boolean[1] { derived volatile }
			{
				initial: 					
				if self.condition.oclIsTypeOf(QuantifiedCondition) then self.graph = self.condition.oclAsType(QuantifiedCondition).morphism.from and self.condition.oclAsType(QuantifiedCondition).graph = self.condition.oclAsType(QuantifiedCondition).morphism.to
				else self.condition.getNextQuantifiedConditions->forAll(e|self.graph = e.morphism.from and e.graph = e.morphism.to) endif;
				}
				invariant morphismValid: self.checkMorphismOfNextGraph;
			}
			abstract class Condition extends PatternElement
			{
				attribute condDepth : ecore::EInt[1] = '-1';
				property getNextQuantifiedConditions : QuantifiedCondition[*] { derived volatile }
				{
					initial: 				
				if self.oclIsTypeOf(QuantifiedCondition) then 
					Set{self.oclAsType(QuantifiedCondition)}
				else 
					if self.oclIsTypeOf(Formula) then 					
						self.oclAsType(Formula).arguments->collect(element: Condition | element.getNextQuantifiedConditions)->asSet()
					else 
						Set{}
					endif
				endif;
				}
			}
			class Morphism extends PatternElement
			{
				property mappings : Mapping[*|1] { ordered composes };
				property from : qualitypatternmodel::graphstructure::Graph[1];
				property to : qualitypatternmodel::graphstructure::Graph[1];
				attribute morphDepth : ecore::EInt[1] = '-1';
				attribute checkSingleElementMappings : Boolean[?] { derived volatile }
				{
					initial: 
						self.mappings->select(f: Mapping | f.oclIsTypeOf(SingleElementMapping))->forAll(m : Mapping | self.from.getAllElements->includes(m.oclAsType(SingleElementMapping).from))
						and
						self.mappings->select(f: Mapping | f.oclIsTypeOf(SingleElementMapping))->forAll(m : Mapping | self.to.getAllElements->includes(m.oclAsType(SingleElementMapping).to));
					}
					attribute checkRelationMappings : Boolean[?] { derived volatile }
					{
						initial: 
						self.mappings->select(f: Mapping | f.oclIsTypeOf(RelationMapping))->forAll(m : Mapping | self.from.getAllRelations->includes(m.oclAsType(RelationMapping).from))
						and
						self.mappings->select(f: Mapping | f.oclIsTypeOf(RelationMapping))->forAll(m : Mapping | self.to.getAllRelations->includes(m.oclAsType(RelationMapping).to));
						}
						invariant singleElementMappingsValid: self.checkSingleElementMappings;
						invariant relationMappingsValid: self.checkRelationMappings;
					}
					class SingleElementMapping extends Mapping
					{
						property from#mappingTo : qualitypatternmodel::graphstructure::SingleElement[1];
						property to#mappingFrom : qualitypatternmodel::graphstructure::SingleElement[1];
					}
					abstract class Mapping extends PatternElement
					{
						attribute mappingDepth : ecore::EInt[1] = '-1';
					}
					class Formula extends Condition
					{
						property arguments : Condition[+|1] { ordered composes };
						attribute operator : LogicalOperator[?];
					}
					class True extends Condition;
					enum LogicalOperator { serializable }
					{
						literal NOT : 'NOT';
						literal AND : 'AND' = 1;
						literal OR : 'OR' = 2;
						literal IMPLIES : 'IMPLIES' = 3;
						literal XOR : 'XOR' = 4;
						literal EQUIVALENT : 'EQUIVALENT' = 5;
					}
					enum Quantifier { serializable }
					{
						literal EXISTS : 'exists';
						literal FORALL : 'forall' = 1;
					}
					class Pattern extends PatternElement
					{
						operation isValid(isDefinedPattern : Boolean[1]) throws InvalidityExceptionWrapper;
						operation toXQuery() : String[?] throws InvalidityExceptionWrapper;
						property returnGraph : qualitypatternmodel::graphstructure::Graph[1] { composes };
						property condition : Condition[1] { composes };
						property variableList#pattern : qualitypatternmodel::inputfields::VariableList[1] { composes };
						attribute checkMorphismOfNextGraph : Boolean[1] { derived volatile }
						{
							initial: 					
								if self.condition.oclIsTypeOf(QuantifiedCondition) then self.returnGraph = self.condition.oclAsType(QuantifiedCondition).morphism.from and self.condition.oclAsType(QuantifiedCondition).graph = self.condition.oclAsType(QuantifiedCondition).morphism.to
								else self.condition.getNextQuantifiedConditions->forAll(e|self.returnGraph = e.morphism.from and e.graph = e.morphism.to) endif;
							}
							invariant morphismValid: self.checkMorphismOfNextGraph;
						}
						abstract class PatternElement
						{
							operation toXQuery(location : Location[?]) : String[?] throws InvalidityExceptionWrapper;
							operation getAllInputs() : qualitypatternmodel::inputfields::Input[*|1] throws InvalidityExceptionWrapper {
							ordered };
							operation getNewId() : ecore::EInt[1] throws InvalidityExceptionWrapper;
							operation prepareTranslation();
							operation isValid(isDefinedPattern : Boolean[1]) throws InvalidityExceptionWrapper;
							operation isValidLocal(isDefinedPattern : Boolean[1]) throws InvalidityExceptionWrapper;
							attribute id : ecore::EInt[1] { id };
							callable invariant validate;
						}
						enum Location { serializable }
						{
							literal RETURN : 'RETURN' = 1;
							literal OUTSIDE;
							literal EXISTS : 'EXISTS' = 2;
							literal FORALL : 'FORALL' = 3;
						}
						datatype InvalidityExceptionWrapper : 'qualitypatternmodel.patternstructure.InvalidityException' { serializable
						};
					}
				}