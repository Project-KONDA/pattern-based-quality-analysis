+++ Constraints for the quality pattern model +++


each Element has exactly one previousElement except for Graph.rootElement, which has no previousElement

SetElement:
invariant hasPrevious: self.previous->notEmpty();

SingleElement:
invariant hasPreviousOrIsRoot: self.previous->notEmpty() or self.root->notEmpty();

(
for each Graph only the rootElement has root = true
+ context Graph inv GraphRootAttributeValid: self->GraphRootAttributeValid()

+ context Graph::GraphRootAttributeValid: boolean derive:
	self.rootElement.root = true and self.rootElement->getNextElements()->select(e|e.oclIsTypeOf(SingleElement))->forall(e|e->NotRoot())
	
+ context SingleElement::NotRoot: boolean derive:
	self.root = false and self->getNextElements()->select(e|e.oclIsTypeOf(SingleElement))->forall(e|e->NotRoot())
)
(
for a defined pattern:
- Text.text must be defined
	+ context Text inv TextDefined: text->notEmpty()
- Number.number must be defined
	+ context Number inv NumberDefined: number->notEmpty()
- Boolean.bool must be defined
	+ context Boolean inv BooleanDefined: bool->notEmpty()
- Option.selection must be defined
	+ context Option inv OptionDefined: selection->notEmpty()
)

QuantifiedCondition.morphsim.from = QuantifiedCondition.getParentGraph()
QuantifiedCondition.morphsim.to = QuantifiedCondition.graph

QuantifiedCondition:
attribute checkMorphismOfNextGraph : Boolean[1] { derived volatile }
{
	initial: 					
	if self.condition.oclIsTypeOf(QuantifiedCondition) then self.graph = self.condition.oclAsType(QuantifiedCondition).morphism.from and self.condition.oclAsType(QuantifiedCondition).graph = self.condition.oclAsType(QuantifiedCondition).morphism.to
	else self.condition.getNextQuantifiedConditions->forAll(e|self.graph = e.morphism.from and e.graph = e.morphism.to) endif;
}
invariant morphismValid: self.checkMorphismOfNextGraph;
				
Condition:
property getNextQuantifiedConditions : QuantifiedCondition[*] { derived volatile }
{
	initial: 				
	if self.oclIsTypeOf(QuantifiedCondition) then 
		Set{self.oclAsType(QuantifiedCondition)}
	else 
		if self.oclIsTypeOf(Formula) then 					
			self.oclAsType(Formula).arguments->collect(element: Condition | element.getNextQuantifiedConditions)->asSet()
		else 
			Set{}
		endif
	endif;
}	
		
Pattern:
attribute checkMorphismOfNextGraph : Boolean[1] { derived volatile }
{
	initial: 					
		if self.condition.oclIsTypeOf(QuantifiedCondition) then self.returnGraph = self.condition.oclAsType(QuantifiedCondition).morphism.from and self.condition.oclAsType(QuantifiedCondition).graph = self.condition.oclAsType(QuantifiedCondition).morphism.to
		else self.condition.getNextQuantifiedConditions->forAll(e|self.returnGraph = e.morphism.from and e.graph = e.morphism.to) endif;
}
invariant morphismValid: self.checkMorphismOfNextGraph;
		

SingleElementMapping.from.getGraph() = SingleElementMapping.getParent().from
SingleElementMapping.to.getGraph() = SingleElementMapping.getParent().to
RelationMapping.from.getGraph() = RelationMapping.getParent().from
RelationMapping.to.getGraph() = RelationMapping.getParent().to

Morphism:
attribute checkSingleElementMappings : Boolean[?] { derived volatile }
{
	initial: 
		self.mappings->select(f: Mapping | f.oclIsTypeOf(SingleElementMapping))->forAll(m : Mapping | self.from.getAllElements->includes(m.oclAsType(SingleElementMapping).from))
		and
		self.mappings->select(f: Mapping | f.oclIsTypeOf(SingleElementMapping))->forAll(m : Mapping | self.to.getAllElements->includes(m.oclAsType(SingleElementMapping).to));
}
attribute checkRelationMappings : Boolean[?] { derived volatile }
	{
		initial: 
		self.mappings->select(f: Mapping | f.oclIsTypeOf(RelationMapping))->forAll(m : Mapping | self.from.getAllRelations->includes(m.oclAsType(RelationMapping).from))
		and
		self.mappings->select(f: Mapping | f.oclIsTypeOf(RelationMapping))->forAll(m : Mapping | self.to.getAllRelations->includes(m.oclAsType(RelationMapping).to));
	}
invariant singleElementMappingsValid : self.checkSingleElementMappings;	
invariant relationMappingsValid : self.checkRelationMappings;	

Graph :	
property getAllElements : Element[*] { derived volatile }
{
	initial: 
	self.rootElement.getAllElements;
}
property getAllRelations : Relation[*] { derived volatile }
{
	initial: 
	self.rootElement.getAllRelations;
}

Element:	
property getAllElements : Element[*] { derived volatile }
{
	initial: 
	 self.getNextElements()->collect(e: Element | e.getAllElements)->asSet()->including(self);
}
property getAllRelations : Relation[*] { derived volatile }
{
	initial: 
	 self.getNextElements()->collect(e: Element | e.getAllRelations)->asSet()->including(self.relationFromPrevious);
}
	
----

Annahme: predicates Kante ist bidirektional

context BooleanOperator inv PredicateValid: self->PredicateValid()

context BooleanOperator::PredicateValid: boolean derive:
	self.elements->forall(e|self->getAllArgumentElements()->includes(e))
	and
	self->getAllArgumentElements()->forall(l|l->exists(e|elements.includes(e)))

context BooleanOperator::getAllArgumentElements: Set{Set{Element}} derive:
	if self.oclIsTypeOf(Comparison) then 
		argument1->getAllArgumentElements()->union(argument2->getAllArgumentElements())
	else if self.oclIsTypeOf(Match) then
		self.property->getAllArgumentElements()
	else Set{}
	
context GraphElement::getAllArgumentElements: Set{Set{Element}} derive:
	if self.oclIsTypeOf(SingleElement) then
		Set{self}
	else if self.oclIsTypeOf(SetElement) then
		Set{self->getSetPrevious()}
	else if self.oclIsTypeOf(Count) then
		argument->getAllArgumentElements()
	else if self.oclIsTypeOf(ToNumber) then
		property->getAllArgumentElements()	
	else if self.oclIsTypeOf(Property) then
		self.element->getAllArgumentElements()
	else Set{}
	
context SetElement::getSetPrevious: Set{Element} derive:
	if self.previous.oclIsTypeOf(SetElement) then	
		self.previous->getSetPrevious()->including(self)
	if self.previous.oclIsTypeOf(SingleElement) then	
		Set{self.previous}


for each BooleanOperator with elements != null:
	List<List<Element>> arguments := getAllArgumentElements()
	for each x in elements:
		x must be in arguments.flatten()
	for each list in arguments:
		boolean b = false;
		for each element in list:
			if element in elements:
				b = true
		b must be true
		
SingleElement.getAllArgumentElements() adds this to the list
SetElement.getAllArgumentElements() adds a list of all SetElements between this and the first SingleElement reached via getPreviousElement() as well as the SingleElement to the list

(
When using a set operator:
- let e of type ELEMENT be the element(s) which reference(s) the predicate containing the set operator
- let s of type SETELEMENT be the element(s) which serve(s) as an argument to the set operator
- there has to exist a path from each e to at least one s in the graph
- for each s there must exist a path from one e to s in the graph
- between e and s only SETELEMENTs are allowed (connected via RELATION) [and they are not allowed to be the argument of a set operator]
)